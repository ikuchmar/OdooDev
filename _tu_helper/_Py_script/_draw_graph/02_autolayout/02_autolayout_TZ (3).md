# 02_autolayout — Описание и ТЗ (Графы / draw_graph)

**Версия документа:** 1.0  
**Модуль:** `02_autolayout`  
**Назначение:** Автоматическая раскладка графа (назначение координат узлам и прокладка рёбер) на основе входной структуры, подготовленной предыдущими шагами пайплайна.

---

## 1) Краткое описание и место в пайплайне

`02_autolayout` — второй этап конвейера `draw_graph`. Он принимает на вход «логический» граф (узлы/рёбра без координат) из этапа `01_prepare`, применяет алгоритм авторазмещения и возвращает «геометрический» граф: все узлы имеют координаты и размеры, рёбра — маршрут/контрольные точки. Результат используется дальше (например, на этапе визуализации/рендера).

**Контекст пайплайна:**  
1. `01_prepare` — парсинг исходных данных, нормализация структуры, первичная валидация.  
2. `02_autolayout` — вычисление координат/маршрутов.  
3. `03_draw` (или аналог) — отрисовка/экспорт.

---

## 2) Входы и выходы

### Входные данные
- **Граф** (JSON / TOML / YAML — формат задаётся конфигом):  
  - `nodes`: список узлов. Поля, используемые в раскладке:
    - `id` (строка, уникальная) — обязательное
    - `title`/`label` (строка) — опционально
    - `size`: `{ "w": int, "h": int }` — опционально (если нет — берём из конфига `defaults.node_size`)
    - `fixed`: `true|false` — опционально (если `true`, координаты не меняем)
    - `pos`: `{ "x": float, "y": float }` — опционально (если `fixed=true` — перейти в абсолют)
    - `group` / `rank` / `layer` — опционально, для иерархий и кластеров
    - любые дополнительные атрибуты — **не ломают** модуль, но игнорируются в геометрии
  - `edges`: список рёбер. Поля:
    - `id` (строка, уникальная) — опционально
    - `source` (string, узел-источник) — обязательно
    - `target` (string, узел-приёмник) — обязательно
    - `label` (строка) — опционально
    - `weight` (float) — опционально
    - `kind`/`type` (строка) — опционально (например, «depends», «uses»)
- **Конфигурация TOML** `02_autolayout/config.toml` (см. далее).

### Выходные данные
- **Обновлённый граф** (в том же или ином формате — задаётся конфигом):
  - у каждого узла появляются/обновляются `pos.x`, `pos.y`;
  - у рёбер — информация о маршруте (например, `points: [{x,y}, …]` для полилиний);
  - нормализация координат (смещение в `(0,0)`, округление, масштабирование) — согласно конфигу.
- **Логи** выполнения (текстовый файл и/или вывод в консоль).
- (Опционально) **диагностические артефакты**: снимок входного графа, «force layout» итерации и т.д.

---

## 3) Конфигурация (TOML)

Файл: `02_autolayout/config.toml`. Модуль запускается без CLI-параметров; всё берём из этого файла.

```toml
# === Общие пути ===
input.graph_path   = "../01_prepare/out/graph.json"   # входной граф
output.graph_path  = "./out/graph_with_layout.json"    # выходной граф
io.format          = "json"                            # json|toml|yaml

# === Логирование/сервисные ===
runtime.dry_run          = false        # только проверить и логировать без записи
runtime.backup_outputs   = true         # делать .bak для существующих файлов
runtime.continue_on_error = false       # прерывать или продолжать при ошибках
runtime.random_seed      = 42

# === Выбор и настройки раскладки ===
layout.engine  = "hierarchical"         # hierarchical|force|grid|manual_only
layout.rankdir = "TB"                   # TB|LR|BT|RL (для иерархий)
layout.layer_spacing = 120              # вертикальный/горизонтальный зазор между уровнями
layout.node_spacing  = 80               # минимальный зазор между узлами в одном уровне
layout.avoid_overlap = true             # попытка избегать наложений (узел-узел)
layout.edge_routing  = "ortho"          # straight|ortho|spline

# Для force-раскладки
force.iterations    = 1000
force.k_spring      = 0.5
force.repulsion     = 2000
force.damping       = 0.9

# === Ограничения/фиксированные узлы ===
constraints.respect_fixed_nodes = true  # если у узла fixed=true — не двигать
constraints.pin_groups          = []    # имена групп/кластера, которые считаем «жёсткими»
constraints.bounds              = [0, 0, 5000, 5000] # [minX, minY, maxX, maxY] или [] — без ограничений

# === Нормализация координат ===
normalize.zero_origin   = true          # сдвиг всей раскладки так, чтобы minX,minY = 0,0
normalize.round_digits  = 2             # округление координат
normalize.scale_factor  = 1.0           # масштабирование (например, 0.5 для сжатия)

# === Размеры по умолчанию ===
defaults.node_size.w = 140
defaults.node_size.h = 48

# === Экспорт/совместимость ===
export.include_intermediate = false     # сохранять промежуточные состояния/итерации
export.pretty_print         = true      # форматирование JSON
```

> **Примечания:**
> - При `layout.engine = "manual_only"` модуль лишь валидирует/нормализует существующие `pos` и ничего не рассчитывает.
> - Для `hierarchical` учитывается `rankdir`, `layer_spacing`, `node_spacing` и поле узла `rank/layer` (если есть).
> - Для `force` игнорируется `rankdir`, но учитываются `iterations`, `repulsion`, `k_spring`, `damping`.
> - `edge_routing="ortho"` добавит полилинии с прямыми углами; `spline` — сглаженные кривые; `straight` — сегмент `source→target`.

---

## 4) Алгоритм работы

1. **Загрузка конфига** → валидация обязательных полей, нормализация путей.
2. **Загрузка входного графа** → валидация схемы `nodes/edges` (наличие `id`, `source/target` и т.д.).
3. **Подготовка внутренних структур**:
   - построение индексов по `id`;
   - применение размеров по умолчанию;
   - учёт `fixed` и уже существующих `pos`.
4. **Применение выбранного layout-движка**:
   - `hierarchical`: группировка по уровням, компоновка по рангу, разнос по `node_spacing`, учёт `rankdir`;
   - `force`: итеративная силовая модель (пружины/отталкивания), поддержка `fixed`-узлов;
   - `grid`: равномерная сетка (по группам/слоям/размерам).
5. **Маршрутизация рёбер**:
   - `straight|ortho|spline`; попытка избегать пересечений с узлами при `avoid_overlap=true`.
6. **Нормализация координат**:
   - `zero_origin`, `round_digits`, `scale_factor`.
7. **Сохранение результата**:
   - запись выходного графа;
   - (опционально) сохранение промежуточных артефактов;
   - логи/метрики (время, счётчики узлов/рёбер, статистика коллизий).

---

## 5) Требования к устойчивости и ошибкам

- Любая ошибка чтения/валидации должна содержать:
  - путь к проблемному файлу;
  - ключ/узел/ребро, на котором упали;
  - краткий совет, как исправить.
- При `continue_on_error=false` — немедленный выход с кодом ≠ 0.
- При `continue_on_error=true` — пропускаем дефектные элементы, но логируем все пропуски.
- Все предупреждения/ошибки дублируются в лог-файл рядом с `output.graph_path`.

---

## 6) Совместимость форматов

Поддерживаются **json|toml|yaml** (зависит от доступности парсеров в проекте).  
В JSON результат сохраняется с `export.pretty_print=true` для удобства диффов.

**Схема (JSON, упрощённо):**
```json
{
  "nodes": [
    { "id": "A", "label": "Start", "size": {"w":140,"h":48}, "fixed": false, "pos": {"x": 12.5, "y": 80.0} }
  ],
  "edges": [
    { "source": "A", "target": "B", "label": "", "points": [{"x":13,"y":90},{"x":58,"y":90}] }
  ]
}
```

---

## 7) Мини‑гайд по использованию

1. Отредактируйте `02_autolayout/config.toml` под свой вход/выход и параметры раскладки.
2. Запустите скрипт `02_autolayout/autolayout.py` **без аргументов**.
3. Проверьте лог (консоль и/или файл).
4. Заберите `output.graph_path` для дальнейшей визуализации.

---

## 8) Набор проверок (чек‑лист)

- [ ] Входной файл существует и корректен (минимум 1 узел).  
- [ ] Все `edges[*].source/target` ссылаются на существующие `nodes[*].id`.  
- [ ] В конфиге выбран валидный `layout.engine`.  
- [ ] При `respect_fixed_nodes=true` фиксированные узлы остались на месте.  
- [ ] Нет отрицательных координат после `normalize.zero_origin=true`.  
- [ ] Выходной файл сформирован, координаты округлены по `round_digits`.

---

## 9) Мастер‑промт для продолжения разработки в новом чате

> **Скопируйте и вставьте целиком в новый чат того же проекта:**

**Роль/контекст:** Мы продолжаем разработку модуля `02_autolayout` проекта `draw_graph`. Используем Python 3.8+ без внешних зависимостей (если не оговорено отдельно). Конфигурация — TOML. Запуск без CLI‑параметров, все настройки в `02_autolayout/config.toml`. Вход — граф (nodes/edges), Выход — тот же граф с координатами узлов и маршрутами рёбер.  

**Задачи на итерацию:**  
1) Проверить и улучшить иерархическую раскладку: поддержка `rankdir`, `layer_spacing`, `node_spacing`, respect fixed nodes.  
2) Добавить/уточнить маршрутизацию рёбер: `straight|ortho|spline`.  
3) Реализовать нормализацию: `zero_origin`, `round_digits`, `scale_factor`.  
4) Обновить и описать схему JSON (nodes/edges/points).  
5) Настроить логи/ошибки: детальный отчёт по пропускам/коллизиям.  

**Критерии приёмки:**  
- Скрипт запускается без аргументов и читает `config.toml`.  
- При любом `engine` возвращает валидный граф с координатами для всех не‑fixed узлов.  
- Включённый `avoid_overlap` снижает число наложений на тестовом наборе.  
- Результат стабильный при одинаковом `random_seed`.  
- Конфиг документирован и покрывает все параметры из ТЗ.

**Ограничения:**  
- Не генерировать код без явного запроса.  
- Любые файлы предоставлять **полными**, в виде ссылок на загрузку.  
- Сохранить совместимость форматов (json|toml|yaml) и запуск «без параметров».

---

## 10) История изменений документа

- **1.0 (текущая):** Базовое описание и полное ТЗ для `02_autolayout`.
