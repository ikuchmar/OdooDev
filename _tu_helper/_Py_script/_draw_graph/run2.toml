# =========================
#  ФАЙЛ НАСТРОЕК: run.toml
# =========================
# Этот файл читается скриптом draw_graph.py, который лежит рядом.
# Скрипт запускается БЕЗ аргументов командной строки:
#     python draw_graph.py
#
# Все параметры, указанные В САМОМ ГРАФЕ (в его TOML), перекрывают значения здесь.
# Параметры ниже снабжены комментариями и допустимыми значениями.

# --- Где искать файлы графов (TOML) ---
# Можно указать несколько путей. По каждому пути выполняется поиск (обычно рекурсивно).
input_dirs = [
"D:/Entertaiment/Графы/Пример 1"
  # , "D:/Проекты/Диаграммы"
]

# Рекурсивно обходить подпапки?
# true  — искать во всех подпапках;
# false — брать только файлы из самой папки.
recursive = true

# Обрабатывать только файлы с такими расширениями (без точки).
include_extensions = ["toml"]

# Исключить из обработки пути, подходящие под эти шаблоны (fnmatch/glob).
# Пример: исключить архивы и бэкапы.
exclude_patterns = ["*/_archive/*", "*_bak.toml"]


# -----------------
#  СЕКЦИЯ LAYOUT
# -----------------
[layout]

# Режим раскладки:
# - "layered" (по слоям, слева-направо по умолчанию) — рекомендовано для блок-схем и зависимостей;
# - "force"   (упрощённая силовая модель);
# - "off"     (ничего не раскладывать; использовать только те pos, что уже записаны в блоках или layout_result).
mode = "layered"

# Направление для layered-раскладки:
#  LR — слева направо (Left-to-Right),
#  RL — справа налево,
#  TB — сверху вниз (Top-to-Bottom),
#  BT — снизу вверх.
direction = "LR"

# Минимизировать пересечения рёбер (эвристика; актуально для layered).
minimize_edge_crossings = true

# Разводить блоки так, чтобы они не наслаивались друг на друга.
avoid_node_overlap = true

# Маршрут рёбер (геометрия линии):
#  "straight"    — прямая линия,
#  "orthogonal"  — ломаная под прямыми углами (L-образно),
#  "spline"      — гладкая кривая,
#  "auto"        — выбор автоматически (на layered = "orthogonal", иначе "straight/curve").
edge_routing = "straight"

# Размещение подписи ребра:
#  "smart"   — умно подстраивать местоположение (в текущей простой реализации — как "center+offset"),
#  "center"  — по центру (смещение задаётся через defaults.style.label_offset).
edge_label_placement = "center"

# Минимальный зазор между блоками (нормированная величина в долях ширины/высоты холста).
# На практике отвечает за «воздух» вокруг блоков в авторазводке.
node_padding = 0.02

# Привязка координат к сетке при записи (нормированная величина, например 0.01 — шаг 1%).
grid_snap = 0.01

# Детерминированная раскладка (true) — при одинаковом seed результат один и тот же.
deterministic = true

# Начальное значение генератора случайных чисел (для force и некоторых эвристик).
seed = 42

# Уважать «зафиксированные» блоки:
# true  — если у блока задан pos (в блоке или layout_result), авто-раскладка его не двигает;
# false — двигать можно все блоки.
respect_fixed_blocks = true

# Количество итераций для "force" (игнорируется для "layered" и "off").
iterations = 500

# Дополнительные зазоры для layered:
# layer_gap — зазор между «слоями» по главной оси (нормированная величина),
# node_gap  — зазор между соседними блоками ВНУТРИ одного слоя (нормированная).
layer_gap = 0.08
node_gap  = 0.03


# ------------------
#  СЕКЦИЯ PERSIST
# ------------------
[persist]

# Записывать ли рассчитанные позиции обратно в файл графа.
write_positions_to_input = true

# Режим записи позиций:
#  "overwrite"      — перезаписывать все позиции;
#  "update_missing" — дописывать только те блоки, у которых позиций не было.
write_mode = "overwrite"

# Порядок сортировки при записи позиций (чисто косметически):
#  "by_pos_id" — по (x, y, id),
#  "by_id"     — по id.
sort_blocks = "by_pos_id"

# Порядок сортировки стрелок (если где-то потребуется сериализация).
#  "by_from_to_label" | "none"
sort_arrows = "by_from_to_label"

# Создавать *.bak перед изменением исходного файла графа?
create_backup = false

# Дополнительно: записывать «геометрию» прямо в [[blocks]] (а не только в [layout_result])?
# true — да; false — нет.
write_block_geometry = true

# Какие поля геометрии сохранять в каждом [[blocks]]:
#  - "pos"            — нормированные координаты центра [x, y] (0..1),
#  - "width"          — нормированная ширина блока,
#  - "header_height"  — нормированная высота шапки,
#  - "prop_height"    — нормированная высота одной строки свойства.
persist_geometry_fields = ["pos", "width", "header_height", "prop_height"]


# -----------------
#  СЕКЦИЯ OUTPUT
# -----------------
[output]

# Сохранять ли PNG и SVG. SVG сохраняется всегда; PNG — при установленном пакете "cairosvg".
save_png = true
save_svg = true

# DPI для PNG (если включен save_png).
png_dpi = 200

# Имя выходных файлов:
#  "same_basename" — рядом с исходным TOML создаются файлы X.svg и X.png.
file_naming = "same_basename"

# Открыть результат в браузере:
#  "none" — не открывать,
#  "svg"  — открыть SVG (рекомендуется).
open_in_browser = "svg"

# Показывать ли окна предпросмотра (в этой версии не используется).
show_preview_windows = false


# -----------------
#  СЕКЦИЯ DEFAULTS
# -----------------
[defaults]

# Размер холста в пикселях. На его основе нормированные размеры переводятся в пиксели.
canvas_size = [1200, 800]

# Глобальные стили рёбер и подписей (их можно переопределять в конкретной стрелке).
style.curve = "auto"            # auto | straight | arc | spline
style.label_offset = 0.50       # 0..1 (0 — начало линии, 0.5 — середина, 1 — конец)
style.connector_from = "auto"   # auto | left | right | top | bottom
style.connector_to = "auto"     # auto | left | right | top | bottom
style.arrow_size = 1.0          # размер стрелки (коэффициент)
style.arrow_thickness = 2.0     # толщина линии (px)

# Габариты блоков (нормированные). Итоговая высота = header_height + prop_height * (кол-во свойств).
# Если нужно компактнее — уменьшите prop_height (например 0.06) и/или header_height.
block.width = 0.22
block.header_height = 0.12
block.prop_height = 0.06
block.corner_radius = 10        # скругление рамки (px)
block.stroke_width = 2.0        # толщина рамки (px)
block.fill_color = "none"       # заливка блока (например "#FFFFFF" или "none")
block.stroke_color = "#000000"  # цвет рамки

# Шрифты
font.family = "Arial"
font.size_title = 14
font.size_prop = 12
font.size_arrow = 11
font.bold_title = true
font.italic_arrow = true

# Тема (цвета фона и текста). Можно сделать тёмную тему, поменяв background/text_color.
theme.mode = "light"
theme.background = "#FFFFFF"
theme.text_color = "#000000"
theme.arrow_color = "#222222"
theme.block_fill_color = "none"
theme.block_stroke_color = "#000000"